# IOSUI Navigation Project

## Задача 1
<<<<<<< HEAD

Добавьте библиотеку SnapKit через менеджер зависимостей Cocoapods. Используйте последнюю версию библиотеки.
Перепишите и сделайте вёрстку визуальных объектов класса ProfileHeaderView при помощи SnapKit.
Проверьте, что ваша вёрстка хорошо смотрится на экранах различных устройств от iPhone SE до iPhone 13 Pro Max.

## Задача 2

Установите учебную библиотеку iOSIntPackage через менеджер зависимостей Swift Package Manager.
Используйте последнюю версию библиотеки.
Используя метод processImage структуры ImageProcessor добавьте различные фильтры для картинок,
которые отображаются в постах (класс PostTableViewCell). Не перепутайте с картинками в разделе Photos,
для них будет отдельное задание позднее.
Поэкспериментируйте с различными фильтрами для картинок постов, выберите тот, который вам больше 
всего нравится. Убедитесь, что фильтр работает на всех постах.
=======
1. Сделаем как синглтон специальный сервис для проверки логина и пароля под названием Checker. 
Пока этот сервис будет иметь один интерфейсный метод для проверки логина и пароля, введённого пользователем.
2. Создайте новый класс Checker и сделайте его синглтоном.
3. В классе Checker сделайте приватные свойства login и password, пусть они будут константами и будут иметь выбранные вами значения в заранее заданном виде.
4. В классе Checker сделайте метод check, который будет принимать логин и пароль, введенные пользователем и возвращать true,
если и логин и пароль будут совпадать и false — если нет.
5. Создайте новый протокол LoginViewControllerDelegate, для него пропишите один метод check, который будет использовать созданный выше синглтон Checker.
6. Для класса LoginViewController сделайте свойство loginDelegate с типом LoginViewControllerDelegate. Метод делегата будет проверять значения,
введённые в текстовых полях контроллера. Напрямую вызывать из контроллера сервис Checker в этой работе нельзя.
7. Создайте новую структуру LoginInspector и подпишите её на протокол LoginViewControllerDelegate; сделайте в ней реализацию метода протокола. 
8. LoginInspector должен проверять соответствие введённого логина и пароля с помощью синглтона Checker. Важный момент: чтобы делегат мог сообщить 
контроллеру результат проверки логина и пароля, метод протокола делегата должен содержать возвращаемое значение.
9. Внедрите зависимость контроллера LoginViewController от LoginInspector, то есть присвойте значение свойству делегата в классе SceneDelegate или AppDelegate.
10. Реализуйте в LoginViewController проверку логина и пароля, введённого пользователем с помощью loginDelegate. Выведите сообщение о неверном логине 
или пароле с помощью UIAlertController, если они неверные. Подумайте, как логично интегрировать сделанный в предыдущем задании UserService,
который предоставляет информацию о пользователе для его профиля, c проверкой на входе логина и пароля c использованием LoginInspector.
11. Проверьте, что если в вашем приложении введены неверные логин или пароль, то выводится предупреждение, а если они совпадают с зарегистрированными, 
то пользователь попадает на экран профиля. Пусть вас не смущает, что логин и пароль зарегистрированы статично. Мы это усовершенствуем позднее.

## Задача 2
1. Сделаем фабрику для производства объектов проверки пароля.
2. Создайте новый протокол LoginFactory с одним методом без параметров makeLoginInspector, который будет возвращать LoginInspector.
3. Сделайте новую структуру MyLoginFactory, которая будет удовлетворять требованиям протокола LoginFactory и содержать генератор экземпляра LoginInspector
4. Вынесите генерацию LoginInspector в SceneDelegate (или AppDelegate) через фабрику: теперь экземпляр делегата для LoginViewController должен создаваться 
через фабрику, а не напрямую.
5. Проверьте, что теперь сервис проверки логина и пароля успешно работает через фабрику. Конечно, сейчас фабрика не очень нужна для генерации единственного 
экземпляра одного класса или структуры, но зато вы освоили сам метод, паттерн фабрики и теперь можете его использовать для генерации изделий массового
спроса в коде ваших будущих приложений.
>>>>>>> feature/task
